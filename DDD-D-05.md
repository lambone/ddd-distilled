## 第五章、使用聚合体的战术设计 

到目前为止，我已经讨论了有边界的上下文、子域和上下文图的战略设计。在这里，你可以看到两个有边界的上下文，一个是名为敏捷项目管理上下文的核心域，另一个是通过上下文映射整合提供协作工具的支持子域。 

但是，那些生活在 "有界背景 "中的概念呢？我已经提到了这些，但我接下来会更详细地介绍它们。它们可能是你模型中的聚合体。 


为什么使用 

你在这两个Bounded Contexts中看到的每一个被圈起来的概念都是一个集合体。一个没有被圈起来的概念\--讨论\--被建模为一个价值对象。即便如此，我们在这一章中还是把重点放在了聚合上，我们将仔细看看如何对产品进行建模。

BacklogItem，Release，和Sprint。 

### 什么是实体？ 

一个实体是一个单独的事物的模型。每个实体都有一个独特的身份，你可以从所有其他相同或不同类型的实体中区分出它的个性。很多时候，也许甚至大多数时候，一个实体将是可变的；也就是说，它的状态将随着时间的推移而改变。然而，一个实体并不必然是可变的，它可能是不可变的。将实体与其他建模工具区分开来的主要东西是它的独特性--它的个体性。 

关于实体的详尽处理，请参见《实施领域驱动设计》\[IDD\]。 

什么是集合体？这里有两个代表。每个聚合体由一个或多个实体组成，其中一个实体被称为聚合体根。Aggregates也可以由Value Objects组成。正如你在这里看到的，Value Objects被用在两个Aggregates里面。 

### 什么是价值对象？ 

一个价值对象，或者简单说是一个价值，对一个不可改变的概念整体进行建模。在这个模型中，Value只是一个值。不像 Entity ，它没有唯一的身份，等价性是通过比较 Value 类型所封装的属性来确定的。此外，Value对象不是一个事物，而是经常被用来描述、量化或测量一个实体。 

关于价值对象的详细内容，请参见《实施领域驱动设计》\[IDDD\]。

每个聚合体的根实体拥有聚集在它里面的所有其他元素。根实体的名字是聚合体的概念名称。你应该选择一个能正确描述聚合体模型的概念性整体的名称。 

每个聚合体形成一个事务性的一致性边界。这意味着在一个单一的聚合体中，根据业务规则，所有组成部分必须是一致的，当控制的事务被提交到数据库中。这并不一定意味着你不应该在一个聚合体中组成不需要在事务后保持一致的其他元素。毕竟，Aggregate也是一个概念性的整体模型。但是你应该首先关注事务的一致性。在Aggregate Type 1和Aggregate Type 2周围画出的外部边界代表了一个单独的事务，这个事务将控制每个对象集群的原子持久化。 

交易的更广泛含义 

在某种程度上，在你的应用程序中使用事务是一个实现细节。例如，一个典型的用法是由一个应用服务\[IDDD\]代表领域模型控制原子数据库事务。在不同的架构下，例如Actor模型\[Reactive\]，每个Aggregate都被实现了作为一个角色，交易可以使用事件源（Event Sourcing）来处理（见下一章），而数据库不支持原子交易。无论怎样，我所说的 "事务 "是指如何隔离对聚合体的修改，以及如何保证业务不变性--软件必须始终遵守的规则--在每个业务操作之后保持一致。无论这一要求是由原子数据库事务控制还是由其他方式控制，聚合体的状态或其通过事件源的表示，都必须在任何时候安全、正确地过渡和维护。 

交易边界的原因是出于业务的考虑，因为是业务决定了在任何时候集群的有效状态应该是什么。换句话说，如果聚合体没有被存储在一个完整有效的状态下，根据业务规则，所执行的业务操作将被认为是不正确的。 

从另一个角度来考虑这个问题，请考虑这个问题。虽然这里有两个聚合体，但在一个事务中只应提交其中一个。这是一个一般的规则 

Aggregate设计：在一个事务中只修改和提交一个Aggregate实例。这就是为什么你在一个事务中只看到Aggregate Type 1的实例。我们很快就会看到Aggregate设计的其他规则。

任何其他的Aggregate将在一个单独的事务中被修改和提交。这就是为什么说Aggregate是一个事务性的一致性边界。所以，你要以一种允许交易一致性和成功的方式来设计你的Aggregate组合。正如这里所看到的，聚合类型2的实例被控制在与聚合类型1的实例分开的事务中。 

由于这两个聚合体的实例被设计成在不同的事务中被修改，我们如何根据对聚合体类型1的实例所做的修改来更新聚合体类型2的实例，我们的领域模型必须对其做出反应？这是个好问题；我们将在本章后面考虑这个问题的答案。 

从这一节要记住的要点是，业务规则是决定在一个交易结束时什么必须是整体的、完整的和一致的驱动因素。 

总的经验法则

接下来让我们考虑一下聚合设计的四个基本规则。 

1. 保护聚合体边界内的业务不变性。 
2. 设计小型骨料。 
3. 仅通过身份参考其他聚合体。 
4. 使用最终的一致性来更新其他聚合体。 

当然，这些规则不一定是由任何 "DDD警察 "严格执行的。它们的目的是作为合理的指导，当经过深思熟虑的应用时，它们将帮助你设计出有效工作的聚合体。既然如此，我们现在将深入研究这些规则，看看应该如何尽可能地应用它们。 


规则 1：保护 Aggregate 边界内的业务不变性 规则 1 意味着业务应该根据事务提交时必须一致的内容来最终确定 Aggregate 的组成。在第81页的例子中，产品被设计成在事务结束时，所有组成的ProductBacklogItem实例都必须被核算并与产品根目录一致。另外，Sprint的设计是这样的：在事务结束时，所有组成的CommittedBacklogItem实例都必须被记录下来，并与Sprint根一致。


通过另一个例子，规则1变得更加清晰。这里是BacklogItem Aggregate。有一条业务规则指出："当所有任务实例的剩余时间为零时，BacklogItem的状态必须被设置为DONE。"因此，在一个事务结束时，必须满足这个非常具体的业务不变性。业务需要它。 


规则2:设计小型骨料 

这条规则强调了每个Aggregate的内存占用和交易范围应该相对较小。在前面的图中，所代表的聚合体并不小。在这里，产品实际上包含了一个潜在的非常大的BacklogItem实例的集合，一个大的Release实例的集合，以及一个大的Sprint实例的集合。随着时间的推移，这些集合可能会变得相当大，有成千上万的BacklogItem实例和可能有数百个Release和Sprint的实例。这种设计方法通常是一个非常糟糕的选择。

然而，如果我们把产品聚合体分解成四个独立的聚合体，这就是我们得到的：一个小的产品聚合体，一个小的BacklogItem聚合体，一个小的发布聚合体，和一个小的Sprint聚合体。这些加载速度快，占用内存少，垃圾回收也快。也许最重要的是，这些聚合体将比以前的大集群产品聚合体更频繁地获得交易成功。 

遵循这一规则还有一个好处，那就是每个Aggregate将更容易工作，因为每个相关的任务都可以由一个开发人员来管理。这也意味着，聚合体将更容易测试。 

在设计聚合体时要记住的另一件事是单一责任原则（SRP）。如果你的聚合体试图做太多的事情，那么它就没有遵循SRP，这很可能在它的规模上体现出来。例如，问问你自己，你的产品是否是一个非常集中的Scrum产品的实施，或者它是否也在尝试做其他事情。改变Product的原因是什么：让它成为一个更好的Scrum产品，还是为了管理积压项目、发布和冲刺？你应该仅仅为了使产品成为更好的Scrum产品而改变它。

规则3:仅以身份参考其他总量 

现在，我们已经将大群的Product分解成四个小的Aggregates，每个Aggregates应该如何在需要时引用其他的Aggregates呢？在这里，我们遵循规则3，"只通过身份引用其他聚合体"。在这个例子中，我们看到BacklogItem、Release和Sprint都通过持有一个ProductId来引用Product。这有助于保持聚合体的规模，并防止在同一事务中伸手修改多个聚合体。 

这进一步有助于保持Aggregate设计的小型化和高效化，从而降低内存需求并快速从持久性存储中加载。这也有助于执行不在同一事务中修改其他Aggregate实例的规则。由于只有其他Aggregate的身份，所以没有简单的方法来获得它们的直接对象引用。 

只使用身份引用的另一个好处是，你的聚合体可以很容易地存储在几乎任何一种持久化机制中，如关系数据库、文档数据库、键值存储和数据网格/织物。这意味着你可以选择使用MySQL关系表、基于JSON的存储，如PostgreSQL或MongoDB、GemFire/Geode、Coherence和GigaSpaces。

规则4：使用最终一致性更新其他聚合 这里一个BacklogItem被提交给一个Sprint。BacklogItem和Sprint都必须对此做出反应。首先是BacklogItem知道它已经被提交到Sprint。这是在一个事务中管理的，当BacklogItem的状态被修改为包含它被提交到的SprintId。那么，我们如何确保Sprint也被更新为新提交的BacklogItem的BacklogId？